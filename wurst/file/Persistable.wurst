package Persistable

import PacketIO
import Network
import DataInterfaces
import Base64Data
import Box
import ErrorHandling

/**
    A simple interface allowing to insert custom user code
    during the serialization and deserialization phases
    of Persistable, for example, to introduce encryption
    to the output.
**/
public interface PersistableMiddleware
    /**
        Called right before the data is written to a file.
        The returned BigString will be used instead.
    **/
    function encode(BigString input) returns BigString
    
    /**
        Called right before the data is deserialized from a file.
        The returned BigString will be used instead.
    **/
    function decode(BigString input) returns BigString

/**
    Represents various failures that can occur during loading.

    SUCCESS - No error has occured.
    FAIL_READ - Error while trying to read data. Could be due to a programming error, or failing checksum, which means the file is missing or has been tampered with.
    FAIL_DESERIALIZE - Error while trying to deserialize the class.
    FAIL_NO_PLAYER - Error due to the owner not being present in the game anymore.
**/
public enum LoadStatus
    SUCCESS
    FAIL_READ
    FAIL_DESERIALIZE
    FAIL_NO_PLAYER

public function LoadStatus.toString() returns string
    string status
    switch this
        case SUCCESS
            status = "SUCCESS"
        case FAIL_READ
            status = "FAIL_READ"
        case FAIL_DESERIALIZE
            status = "FAIL_DESERIALIZE"
        case FAIL_NO_PLAYER
            status = "FAIL_NO_PLAYER"
    return status

public interface PersistableLoadCallback
    function onLoaded(LoadStatus status)

public interface PersistableSaveCallback
    function onSaved()

public abstract class Persistable implements DataSerializable
    protected player owner
    private PersistableMiddleware middleware

    construct(player owner)
        this.owner = owner
    
    construct(player owner, PersistableMiddleware middleware)
        this.owner = owner
        this.middleware = middleware

    ondestroy
        if middleware != null
            destroy middleware

    abstract function getPath() returns string
    protected function onLoaded(LoadStatus _status)
    protected function onSaved()

    protected function getWriter() returns DataWriter
        return new Base64DataWriter(MAX_PACKET_LENGTH)

    protected function getReader(BigString data) returns DataReader
        return new Base64DataDecoder().decode(data)

    private function readIntoNetwork(Network network)
        Box<LoadStatus> statusBox = new Box<LoadStatus>(LoadStatus.SUCCESS)
        Box<DataReader> readerBox = new Box<DataReader>(null)

        let readSuccess = try() ->
            PacketReader.open(getPath())

            let checksum = PacketReader.read().toInt()
            var data = PacketReader.readBigString()

            if checksum == 0 or checksum != data.checksum()
                destroy data
                error("Persistable: checksum failed to validate")
            else
                if middleware != null
                    data = middleware.decode(data)
                readerBox.inner = getReader(data)

        let reader = readerBox.inner
        destroy readerBox

        if readSuccess and reader != null
            network.write() (writer) ->
                writer.writeInt(LoadStatus.SUCCESS castTo int)

            let deserializeSuccess = try() ->
                let proxyReader = new HashDataProxyReader(network.getWriter(), reader)
                proxyReader.readSerializable(this)
                destroy proxyReader

            if deserializeSuccess
                destroy statusBox
                if reader != null
                    destroy reader
                return
            else
                statusBox.inner = FAIL_DESERIALIZE
        else
            statusBox.inner = FAIL_READ

        network.write() (writer) ->
            writer.clear()
            writer.writeInt(statusBox.inner castTo int)
        
        destroy statusBox
        if reader != null
            destroy reader

    private function finishLoad(LoadStatus status, PersistableLoadCallback callback)
        onLoaded(status)
        if callback != null
            callback.onLoaded(status)
            destroy callback

    private function finishSave(PersistableSaveCallback callback)
        onSaved()
        if callback != null
            callback.onSaved()
            destroy callback

    function load(PersistableLoadCallback callback)
        let network = new Network(owner)

        if localPlayer == owner
            readIntoNetwork(network)

        network.start() (status, reader) ->
            if status == NetworkResult.ABORTED
                finishLoad(LoadStatus.FAIL_NO_PLAYER, callback)
            else
                let loadStatus = reader.readInt() castTo LoadStatus

                if loadStatus == LoadStatus.SUCCESS
                    if localPlayer != owner
                        this.deserialize(reader)
                    finishLoad(LoadStatus.SUCCESS, callback)
                else
                    finishLoad(loadStatus, callback)

    function load()
        load(null)

    function save(PersistableSaveCallback callback)
        if localPlayer == owner
            let writer = getWriter()
            let path   = getPath()
            writer.writeSerializable(this)
            var data = writer.intoEncoder().encode()
            if middleware != null
                data = middleware.encode(data)
            PacketWriter.createFolder(path.substring(0, path.lastIndexOf("/"))) // create only top last folder
            PacketWriter.initialize()
            PacketWriter.write(data.checksum().toString())
            PacketWriter.write(data)
            PacketWriter.commit(getPath())
        finishSave(callback)
    
    function save()
        save(null)
