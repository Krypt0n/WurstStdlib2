package StringEncoder
import HashData
import Execute
import HashMap
import ErrorHandling
import NetworkConfig
import SafetyChecks

// characters that can be sent over the network
public constant STRING_ALPHABET = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
public constant STRING_ALPHABET_LENGTH = compiletime(STRING_ALPHABET.length())
// lookup table for alphabet
let alphabetLookup = new HashMap<int, int>()

function getCharFromIndex(int i) returns string
	if i > STRING_ALPHABET_LENGTH
		error("Network: trying to get invalid character from index '" + i.toString() + "'")
	return STRING_ALPHABET.charAt(i)

function getIndexFromChar(string c) returns int
	int hash
	if (c.toUpperCase() == c and c.toLowerCase() != c) or c == "/"
		hash = ("00" + c).getHash()
	else
		hash = c.getHash()

	if SAFETY_CHECKS_ENABLED and not alphabetLookup.has(hash)
		error("Network: trying to get index from invalid character '" + c + "'")

	return alphabetLookup.get(hash)

// only called in the init block
function precomputeLookup()
	for i = 0 to STRING_ALPHABET_LENGTH - 1
		let c = STRING_ALPHABET.charAt(i)

		if (c.toUpperCase() == c and c.toLowerCase() != c) or c == "/"
			alphabetLookup.put(("00" + c).getHash(), i)
		else
			alphabetLookup.put(c.getHash(), i)

function testCollisions()
	// this test here is mostly to ensure that the StringHash implementation in WC3 never collides
	// for our use case, especially if it's somehow changed by a patch
	for i = 0 to STRING_ALPHABET_LENGTH - 1
		if getIndexFromChar(getCharFromIndex(i)) != i
			Log.error("CollisionTest failed for " + i.toString() + " " + getCharFromIndex(i))
			Log.error("getIndexFromChar() == " + getIndexFromChar(getCharFromIndex(i)).toString())
			Log.error("getCharFromIndex(getIndexFromChar)) == " + getCharFromIndex(getIndexFromChar(getCharFromIndex(i))))
			Log.error("This is a BAD thing and you should report it to wurst devs!")

init
	execute(() -> precomputeLookup())
	execute(() -> testCollisions())

/**
	Utility class to convert a to a series of integers corresponding to positions in STRING_ALPHABET
**/
public class StringEncoder
	private var currentValue = ""
	private var counter = 0

	private var inputWriter = new HashWriter()
	private HashReader inputReader

	private var outputWriter = new HashWriter()
	private HashReader outputReader	
	
	ondestroy
		if inputReader != null
			destroy inputReader

		if inputWriter != null
			destroy inputWriter

		if outputReader != null
			destroy outputReader

		if outputWriter != null
			destroy outputWriter

	private function encodeString(string value)
		let length = value.length()
		counter = 0
		outputWriter.writeInt(length)
		
		executeWhile(CHARS_PER_ENCODE_DECODE, () -> counter < length) ->
			outputWriter.writeInt(getIndexFromChar(value.charAt(counter)))
			counter++

	private function decodeString() returns string
		currentValue = ""
		let length = inputReader.readIntUnchecked()
		counter = 0

		executeWhile(CHARS_PER_ENCODE_DECODE, () -> counter < length) ->
			currentValue += getCharFromIndex(inputReader.readIntUnchecked())
			counter++
		
		return currentValue

	function encode()
		inputReader = inputWriter.intoReader()
		inputWriter = null
		executeWhile(DATA_PER_EXECUTE, () -> inputReader.hasString(), () -> encodeString(inputReader.readString()))
		outputReader = outputWriter.intoReader()
		outputWriter = null

	function decode()
		inputReader = inputWriter.intoReader()
		inputWriter = null
		executeWhile(DATA_PER_EXECUTE, () -> inputReader.hasInt(), () -> outputWriter.writeString(decodeString()))
		outputReader = outputWriter.intoReader()
		outputWriter = null

	function pushString(string value)
		inputWriter.writeString(value)

	function popString() returns string
		return outputReader.readString()

	function pushInt(int value)
		inputWriter.writeInt(value)

	function popInt() returns int
		return outputReader.readIntUnchecked()

	function getIntCount() returns int
		return outputReader.getIntCount()

	function getStringCount() returns int
		return outputReader.getStringCount()

	function hasString() returns boolean
		return outputReader.hasString()
