/********************************************************************************
	Network library by MoriMori.

	Based on TriggerHappy's Sync library.

	Overview:
		In multiplayer games, this package is for synchronizing data between game clients.
		It's useful for when one player is the source of game data, such as from gamecache or file IO.

		Like SyncSimple, it depends on the fact that all network actions in WC3 are
		sequential, and are received by players in the same order that are sent in.

		It uses the SyncStored* natives of the gamecache to send data to other players
		from the sender, and then uses SyncSimple to send a 'finish' event, that will
		only be received by other players after they have also received all sync data.

		The Network class provides 4 independent buffers of data:
			integers,
			reals,
			booleans,
			strings

		each of which can be written/read to using the relevant 
		methods of the HashWriter class.

		Before sending the data, the sender populates the HashWriter with the data that
		they want to send, then Network.start() is called, and data is received from 
		the same buffer inside the callback when it has all been transferred.

		Read SyncSimple docs for a slightly more in-depth overview of this particular
		peculiarity of WC3.

	Usage:
		Sending raw data:
			1. Create a new Network object using:
				// sender is the player to receive data from
				let network = new Network(sender)

			2. Write some local data from one of the players, such as the contents of a file:
				if localPlayer == sender
					let buffer = network.getData()
					buffer.writeInt(...)
					buffer.writeReal(...)
					buffer.writeString(...)
					...

			3. Specify a callback for when Network has finished it's operation and
			all data is available for players to be read, and start the transmission.
			Status will be set to NetworkResult.ABORTED if the player left during
			the transmission, or is not present:
				network.start() (status, buffer) ->
					var int = buffer.readInt()
					var real = buffer.readReal()
					var string = buffer.readString()
					...

		Sending objects implementing DataSerializable:
			You may find yourself sending not simply raw data, but some
			class objects. In this case, your class can implement DataSerializable
			to make your life easier.

			The serialize method takes a buffer and should write the representation
			of the object to the buffer.

			The deserialize method takes a buffer and should populate the object
			with the data from the buffer.

			0. Everything else is the same as previous example, only writing/reading is different.

			1. Make your class implement DataSerializable:
				class MyClass implements DataSerializable
					var field1 = 0
					var field2 = 1
					var field3 = true
					var field4 = "someString"

					// this constructor is optional, however you
					// can use it to make new instances of a class easier
					construct(DataWriter writer)
						deserialize(writer)

					function serialize(DataWriter writer)
						writer.writeInt(field1)
						writer.writeInt(field2)
						writer.writeBoolean(field3)
						writer.writeString(field4)

					function deserialize(DataReader reader)
						field1 = reader.readInt()
						field2 = reader.readInt()
						field3 = reader.readBoolean()
						field4 = reader.readString()

			2. Write instances of MyClass:
				if localPlayer == sender
					let myClass = getMyClassInstance()
					let buffer = network.getData()

					buffer.write(myClass)

			3. Read instances of MyClass:
				network.start() (status, buffer) ->
					let myClass = new MyClass(buffer)

					doSomethingWithMyClass(myClass)


				// or, without the constructor

				network.start() (status, buffer) ->
					// get existing instance
					let myClass = getOldMyClassInstance()

					// update it
					myClass.deserialize(buffer)


		Important notes:
			1. You should always read and write to the buffer in the same order,
			otherwise you are risking improperly reading your data.

			2. You should read all received data immediately as it is received,
			because the Network and associated HashReader objects get destroyed
			after the callback finishes.

	Implementation overview:
		Reference for various claims about performance and operation can be found here:
		https://www.hiveworkshop.com/pastebin/3a4f7861cb884e21312168bd654330585801/
		Original research by TriggerHappy.

		There are several core classes here:
			HashWriter/HashReader
			GamecacheBuffer
			StringEncoder
			GamecacheKeys
			Network

		HashWriter/HashReader are a hashtable-based container with buffer semantics for writing
		integers, reals, booleans, strings and serializables.
		Longer gamecache keys take a longer time to synchronize (for each value synced,
		we also send it's keys), so we use keys of fixed length and send data in multiple
		rounds. Because of this, we can't store all data immediately in the gamecache.
		We also need to know the size of data being sent prior to starting the transmission,
		so we have to store all of it in an intermediate buffer, which is HashWriter.

		Prior to sending, the HashWriter is converted into a HashReader, on the sending player, and all strings 
		in the HashReader are encoded into a buffer of integers, because SyncStoredString 
		doesn't work. The responsible class is StringEncoder.

		After sending, they are decoded back into strings and written to the HashWriter on other players,
		after which the HashWriter is converted into a HashReader.

		GamecacheKeys provides int-string conversion for keys for usage in gamecaches.

		GamecacheBuffer is a gamecache-based container for writing
		integers, reals and booleans. There is a GamecacheBuffer for each primitive type,
		int, bool, real and asciiInts.

		Network is the main class that coordinates HashWriter/HashReader and GamecacheBuffer and does
		all the heavy lifting.

		Before starting the transmission, the maximum amount of data across all primitive buffers
		is calculated, and the amount of required 'sync rounds' is calculated - that is, 
		the amount of times we need to flush/sync data out of the gamecaches to keep key sizes short.

		Since only the local player has any knowledge about the amount of data needed to be sent,
		and consequently, the amount of sync rounds required, we first send a pre-fetch "metadata"
		payload with the amount of data in each buffer and the amount of sync rounds, using fixed
		keys. At the same time, we also send the first payload.

		When a round is received, we write data to the HashWriter, using the metadata to know when
		to stop, and start another sync round if necessary. If it is not necessary,
		we convert the HashWriter into a HashReader and call the finish callback, and destroy the instance.
********************************************************************************/
package Network

import public SyncSimple
import ErrorHandling
import public Execute
import public HashData

import NetworkConfig
import Metadata
import GamecacheKeys
import GamecacheBuffer
import StringEncoder

enum NetworkState
	PREPARING
	SENDING_ROUND
	FINISHED

public enum NetworkResult
	SUCCESS
	ABORTED

interface NetworkFinishedCallback
	function onFinish(NetworkResult status, HashReader buffer)

interface NetworkWriteCallback
	function onWrite(HashWriter writer)

public class Network
	// gamecache used for syncing integers, reals and booleans
	private static constant DATA_CACHE   = InitGameCache("1")
	// gamecache used for syncing strings (as int sequences)
	private static constant STRING_CACHE = InitGameCache("2")

	private var currentState = NetworkState.PREPARING

	// mission key to be used for this instance in all game caches
	private var mkey = GamecacheKeys.get(this castTo int)

	// data writer to store data before syncing
	private var dataWriter = new HashWriter

	// data reader to read data after writing
	private HashReader dataReader

	// encoder to send strings over the network
	private var stringEncoder = new StringEncoder

	// gamecache buffers to sync data in rounds
	private var gcIntBuffer	 = new GamecacheBuffer(DATA_CACHE, mkey, BufferType.INTEGER)
	private var gcRealBuffer	= new GamecacheBuffer(DATA_CACHE, mkey, BufferType.REAL)
	private var gcBooleanBuffer = new GamecacheBuffer(DATA_CACHE, mkey, BufferType.BOOLEAN)
	private var gcStringBuffer  = new GamecacheBuffer(STRING_CACHE, mkey, BufferType.INTEGER)

	// metadata container
	private var metadataStore = new MetadataStore()

	// the player that we are receiving data from
	private player sender

	// metadata about the transmission
	private var meta = EMPTY_META
	private var metaReceived = false

	// we can reuse the metadata tuple for counters since they share a similar purpose
	private var counters = EMPTY_META

	// finish callback
	private NetworkFinishedCallback finishCallback = (NetworkResult _result, HashReader _buffer) -> error("Network: did not specify any callback function")

	construct(player sender)
		this.sender = sender

	ondestroy
		destroy gcIntBuffer
		destroy gcRealBuffer
		destroy gcBooleanBuffer
		destroy gcStringBuffer
		destroy stringEncoder
		destroy metadataStore
		destroy finishCallback

		if dataReader != null
			destroy dataReader

		if dataWriter != null
			destroy dataWriter

	@deprecated("use write() instead")
	function getData() returns HashWriter
		return dataWriter

	function getWriter() returns HashWriter
		return dataWriter

	function write(NetworkWriteCallback callback)
		// double-execute wrap to avoid desyncs
		execute() ->
			if localPlayer == sender
				execute() ->
					callback.onWrite(dataWriter)

	/** aborts the current transmission **/
	private function abort()
		currentState = NetworkState.FINISHED
		finishCallback.onFinish(NetworkResult.ABORTED, null)
		destroy this

	/** sends info about the amount of data to be expected to each player **/
	private function sendMetadata()
		// if the sender disconnected, we can't expect any valid data, so immediately return
		if not sender.isIngame()
			abort()
			return

		if localPlayer == sender
			// initialize the reader
			dataReader = dataWriter.intoReader()
			dataWriter = null

			// push all strings into the string encoder

			executeWhile(DATA_PER_EXECUTE, () -> dataReader.hasString()) ->
				stringEncoder.pushString(dataReader.readString())

			// encode all strings into ints
			stringEncoder.encode()

			// get the amount of individual entities to be synced for each type
			let intCount	  = dataReader.getIntCount()
			let realCount	  = dataReader.getRealCount()
			let booleanCount  = dataReader.getBooleanCount()
			let asciiIntCount = stringEncoder.getIntCount()
			
			// calculate max length in each entity buffer
			let maxLength = max(intCount, realCount, booleanCount, asciiIntCount)

			// calculate the amount of required sync rounds
			// we can only send up to GamecacheKeys.count in each sync round, 
			// so we need to do it multiple times if there's more data than that
			let syncRounds = maxLength div GamecacheKeys.count + 1

			// save the amount of sync rounds required so that other players know how many times they need to read
			meta = metadata(intCount, realCount, booleanCount, asciiIntCount, syncRounds)
			metaReceived = true
			metadataStore.setCounts(meta)
			metadataStore.sync()

		// start sending the first round
		currentState = NetworkState.SENDING_ROUND
		sendRound()

	/** receives info about the transmission after it has been sent by the originating player **/
	private function receiveMetadata()
		if localPlayer == sender
			return
		
		// save the metadata
		meta = metadataStore.getCounts()
		metaReceived = true

	// rudimentary read/write functions for primitives
	// WARNING: LOTS OF BOILERPLATE BELOW
	// sorry, but this is needed to avoid hitting the OP limit without too much of a performance hit

	private function writeInts()
		executeWhile(DATA_PER_EXECUTE, () -> counters.ints < meta.ints and gcIntBuffer.getRemainingWrite() > 0) ->
			gcIntBuffer.writeInt(dataReader.readIntUnchecked())
			counters.ints++


	private function readInts()
		executeWhile(DATA_PER_EXECUTE, () -> counters.ints < meta.ints and gcIntBuffer.getRemainingRead() > 0) ->
			dataWriter.writeInt(gcIntBuffer.readInt())
			counters.ints++


	private function writeReals()
		executeWhile(DATA_PER_EXECUTE, () -> counters.reals < meta.reals and gcRealBuffer.getRemainingWrite() > 0) ->
			gcRealBuffer.writeReal(dataReader.readRealUnchecked())
			counters.reals++


	private function readReals()
		executeWhile(DATA_PER_EXECUTE, () -> counters.reals < meta.reals and gcRealBuffer.getRemainingRead() > 0) ->
			dataWriter.writeReal(gcRealBuffer.readReal())
			counters.reals++


	private function writeBooleans()
		executeWhile(DATA_PER_EXECUTE, () -> counters.booleans < meta.booleans and gcBooleanBuffer.getRemainingWrite() > 0) ->
			gcBooleanBuffer.writeBoolean(dataReader.readBooleanUnchecked())
			counters.booleans++


	private function readBooleans()
		executeWhile(DATA_PER_EXECUTE, () -> counters.booleans < meta.booleans and gcBooleanBuffer.getRemainingRead() > 0) ->
			dataWriter.writeBoolean(gcBooleanBuffer.readBoolean())
			counters.booleans++


	private function writeStrings()
		executeWhile(DATA_PER_EXECUTE, () -> counters.asciiInts < meta.asciiInts and gcStringBuffer.getRemainingWrite() > 0) ->
			gcStringBuffer.writeInt(stringEncoder.popInt())
			counters.asciiInts++


	private function readStrings()
		executeWhile(DATA_PER_EXECUTE, () -> counters.asciiInts < meta.asciiInts and gcStringBuffer.getRemainingRead() > 0) ->
			stringEncoder.pushInt(gcStringBuffer.readInt())
			counters.asciiInts++


	private function sendRound()
		let synchronizer = new SimpleSynchronizer()

		// prepare the gamecaches for a new transmission
		gcIntBuffer.reset()
		gcRealBuffer.reset()
		gcBooleanBuffer.reset()
		gcStringBuffer.reset()

		// make sure there is nothing left-over in the gamecaches
		DATA_CACHE.flushMission(mkey)
		STRING_CACHE.flushMission(mkey)

		if localPlayer == sender
			// write as much queued data as we can
			writeInts()
			writeBooleans()
			writeReals()
			writeStrings()

			// send all data
			gcIntBuffer.sync()
			gcBooleanBuffer.sync()
			gcRealBuffer.sync()
			gcStringBuffer.sync()

		// sync to receive data
		synchronizer.sync()
		synchronizer.onSynced(() -> receiveRound())

	private function receiveRound()
		if not sender.isIngame()
			abort()
			return

		// metadata is sent with the first round, so read it first
		if not metaReceived
			receiveMetadata()

		// receive for all non-senders, since sender already has the data
		if localPlayer != sender
			// unlock the data buffer for writing
			readInts()
			readReals()
			readBooleans()
			readStrings()

		// advance to next round and send it if necessary
		counters.syncs++

		if counters.syncs < meta.syncs
			execute(() -> sendRound())
		else
			// if this is the last round, finalize and call the callback
			if localPlayer != sender
				// decode strings
				stringEncoder.decode()

				executeWhile(DATA_PER_EXECUTE, () -> stringEncoder.getStringCount() > 0) ->
					dataWriter.writeString(stringEncoder.popString())
				
				dataReader = dataWriter.intoReader()
				dataWriter = null

			dataReader.reset()
			currentState = NetworkState.FINISHED
			finishCallback.onFinish(NetworkResult.SUCCESS, dataReader)
			destroy this

	/** this is the function to start sending all data in the intermediate dataWriter buffer, as well as specifying a callback **/
	function start(NetworkFinishedCallback callback)
		finishCallback = callback
		sendMetadata()

		
